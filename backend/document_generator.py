"""
Document Generator - Creates formatted Word and PDF documents from reports
"""
import json
import re
from io import BytesIO
from typing import Dict, List, Optional, Any
from pathlib import Path

from docx import Document
from docx.shared import Pt, RGBColor, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH, WD_UNDERLINE, WD_COLOR_INDEX


class DocumentGenerator:
    """Generates formatted Word and PDF documents from radiology reports"""

    def __init__(self):
        # Yellow background highlighting is applied using WD_COLOR_INDEX.YELLOW
        pass

    def generate_word_document(
        self,
        report_text: str,
        template_skeleton: str,
        formatting_metadata: Optional[str] = None,
        highlight_ai_content: bool = False
    ) -> BytesIO:
        """
        Generate a formatted Word document from report text

        Args:
            report_text: The generated report text
            template_skeleton: The original template skeleton
            formatting_metadata: JSON string with formatting information
            highlight_ai_content: Whether to highlight AI-generated content

        Returns:
            BytesIO object containing the Word document
        """
        doc = Document()

        # Parse formatting metadata if provided
        formatting_data = []
        if formatting_metadata:
            try:
                formatting_data = json.loads(formatting_metadata)
            except json.JSONDecodeError:
                print("Warning: Could not parse formatting metadata")

        # Split report into paragraphs
        report_paragraphs = report_text.split('\n')

        # Identify AI-generated content (text that's different from template)
        ai_content_map = self._identify_ai_content(report_text, template_skeleton) if highlight_ai_content else {}

        # Generate document with formatting
        for i, para_text in enumerate(report_paragraphs):
            if not para_text.strip():
                continue  # Skip empty paragraphs

            # Get formatting for this paragraph if available
            para_formatting = formatting_data[i] if i < len(formatting_data) else None

            # Add paragraph to document
            if para_formatting:
                self._add_formatted_paragraph(
                    doc, para_text, para_formatting, ai_content_map, highlight_ai_content
                )
            else:
                # Add paragraph without specific formatting
                self._add_simple_paragraph(doc, para_text, ai_content_map, highlight_ai_content)

        # Save to BytesIO
        output = BytesIO()
        doc.save(output)
        output.seek(0)
        return output

    def _identify_ai_content(self, report_text: str, template_skeleton: str) -> Dict[str, bool]:
        """
        Identify which parts of the report were generated by AI (not from template)

        Returns a map of text segments to whether they're AI-generated
        """
        ai_content_map = {}

        # Get template lines (structural elements)
        template_lines = set(line.strip() for line in template_skeleton.split('\n') if line.strip())

        # Remove placeholder patterns from template lines for comparison
        placeholder_patterns = [
            r'<[^>]+>',  # <fill>, <Ã  remplir>, etc.
            r'\{[^}]+\}',  # {patient_name}, etc.
        ]

        template_structure = set()
        for line in template_lines:
            # Remove placeholders to get just structural text
            clean_line = line
            for pattern in placeholder_patterns:
                clean_line = re.sub(pattern, '', clean_line).strip()
            if clean_line:
                template_structure.add(clean_line)

        # Mark each line in report as AI-generated or template
        for line in report_text.split('\n'):
            line_stripped = line.strip()
            if not line_stripped:
                continue

            # Check if this line is template structure (headings like FINDINGS:, IMPRESSION:)
            is_template = any(struct in line_stripped for struct in template_structure)

            # If not template structure, it's AI-generated content
            if not is_template:
                ai_content_map[line_stripped] = True

        return ai_content_map

    def _add_formatted_paragraph(
        self,
        doc: Document,
        text: str,
        para_formatting: Dict[str, Any],
        ai_content_map: Dict[str, bool],
        highlight_ai: bool
    ):
        """Add a paragraph with formatting from template"""
        para = doc.add_paragraph()

        # Apply paragraph-level formatting
        if para_formatting.get('paragraph_format'):
            pf = para_formatting['paragraph_format']

            # Apply alignment
            if pf.get('alignment'):
                alignment_str = pf['alignment']
                if 'CENTER' in alignment_str:
                    para.alignment = WD_ALIGN_PARAGRAPH.CENTER
                elif 'RIGHT' in alignment_str:
                    para.alignment = WD_ALIGN_PARAGRAPH.RIGHT
                elif 'JUSTIFY' in alignment_str:
                    para.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

            # Apply style if available
            if pf.get('style') and pf['style'] != 'Normal':
                try:
                    para.style = pf['style']
                except KeyError:
                    pass  # Style not available, use default

        # Add runs with formatting
        runs_data = para_formatting.get('runs', [])

        if runs_data:
            # Use original formatting from template
            for run_data in runs_data:
                run_text = run_data.get('text', '')
                run_format = run_data.get('formatting', {})

                # Check if this is a placeholder that was replaced (AI content)
                is_ai_content = self._is_ai_content(run_text, ai_content_map)

                run = para.add_run(run_text)
                self._apply_run_formatting(run, run_format, is_ai_content and highlight_ai)
        else:
            # No specific run formatting, add text as single run
            is_ai_content = self._is_ai_content(text, ai_content_map)
            run = para.add_run(text)
            if is_ai_content and highlight_ai:
                run.font.highlight_color = WD_COLOR_INDEX.YELLOW

    def _add_simple_paragraph(
        self,
        doc: Document,
        text: str,
        ai_content_map: Dict[str, bool],
        highlight_ai: bool
    ):
        """Add a paragraph without specific formatting"""
        para = doc.add_paragraph()

        # Check if this is AI-generated content
        is_ai_content = self._is_ai_content(text, ai_content_map)

        run = para.add_run(text)
        if is_ai_content and highlight_ai:
            run.font.highlight_color = WD_COLOR_INDEX.YELLOW

    def _apply_run_formatting(self, run, formatting: Dict[str, Any], highlight: bool = False):
        """Apply formatting to a run"""
        if formatting.get('bold'):
            run.bold = True
        if formatting.get('italic'):
            run.italic = True
        if formatting.get('underline'):
            run.underline = WD_UNDERLINE.SINGLE
        if formatting.get('font_name'):
            run.font.name = formatting['font_name']
        if formatting.get('font_size'):
            run.font.size = Pt(formatting['font_size'])

        # Highlight AI-generated content with yellow background
        if highlight:
            run.font.highlight_color = WD_COLOR_INDEX.YELLOW

    def _is_ai_content(self, text: str, ai_content_map: Dict[str, bool]) -> bool:
        """Check if text is AI-generated content"""
        # Simple heuristic: if text contains placeholders, it's template text
        # Otherwise, it's likely AI-generated
        placeholder_patterns = [r'<[^>]+>', r'\{[^}]+\}']

        for pattern in placeholder_patterns:
            if re.search(pattern, text):
                return False  # Contains placeholders, so it's template text

        # Check against known AI content
        return text.strip() in ai_content_map

    def generate_word_with_highlighting(
        self,
        report_text: str,
        template_skeleton: str,
        formatting_metadata: Optional[str] = None
    ) -> BytesIO:
        """
        Generate a Word document with AI-generated content highlighted

        This is a convenience method that enables highlighting by default
        """
        return self.generate_word_document(
            report_text,
            template_skeleton,
            formatting_metadata,
            highlight_ai_content=True
        )

    def generate_word_from_template(
        self,
        report_text: str,
        template_docx_path: str
    ) -> BytesIO:
        """
        Generate a Word document using an existing template file as base

        This preserves all formatting from the original template file
        """
        # Load the template document
        doc = Document(template_docx_path)

        # Clear existing content
        for para in doc.paragraphs:
            para.clear()

        # Add new content
        for line in report_text.split('\n'):
            if line.strip():
                doc.add_paragraph(line)

        # Save to BytesIO
        output = BytesIO()
        doc.save(output)
        output.seek(0)
        return output


class PDFConverter:
    """Converts Word documents to PDF"""

    @staticmethod
    def convert_docx_to_pdf(docx_stream: BytesIO) -> BytesIO:
        """
        Convert a Word document to PDF

        Note: This requires additional dependencies (docx2pdf or LibreOffice)
        For production, consider using a cloud service or LibreOffice headless
        """
        try:
            # Try using docx2pdf library (Windows only)
            from docx2pdf import convert

            # Save docx to temp file
            import tempfile
            with tempfile.NamedTemporaryFile(suffix='.docx', delete=False) as docx_file:
                docx_file.write(docx_stream.getvalue())
                docx_path = docx_file.name

            # Convert to PDF
            pdf_path = docx_path.replace('.docx', '.pdf')
            convert(docx_path, pdf_path)

            # Read PDF to BytesIO
            with open(pdf_path, 'rb') as pdf_file:
                pdf_stream = BytesIO(pdf_file.read())

            # Clean up temp files
            import os
            os.remove(docx_path)
            os.remove(pdf_path)

            return pdf_stream

        except ImportError:
            # Fallback: Use LibreOffice if available
            return PDFConverter._convert_with_libreoffice(docx_stream)

    @staticmethod
    def _convert_with_libreoffice(docx_stream: BytesIO) -> BytesIO:
        """
        Convert Word document to PDF using LibreOffice headless
        """
        import subprocess
        import tempfile
        import os

        # Save docx to temp file
        with tempfile.NamedTemporaryFile(suffix='.docx', delete=False) as docx_file:
            docx_file.write(docx_stream.getvalue())
            docx_path = docx_file.name

        # Get temp directory
        temp_dir = os.path.dirname(docx_path)

        try:
            # Convert using LibreOffice
            subprocess.run([
                'soffice',
                '--headless',
                '--convert-to', 'pdf',
                '--outdir', temp_dir,
                docx_path
            ], check=True, capture_output=True)

            # Read generated PDF
            pdf_path = docx_path.replace('.docx', '.pdf')
            with open(pdf_path, 'rb') as pdf_file:
                pdf_stream = BytesIO(pdf_file.read())

            # Clean up
            os.remove(docx_path)
            os.remove(pdf_path)

            return pdf_stream

        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            print(f"Error converting to PDF with LibreOffice: {e}")
            raise RuntimeError(
                "PDF conversion requires LibreOffice. "
                "Install with: apt-get install -y libreoffice"
            )


# Convenience functions
def generate_report_word(
    report_text: str,
    template_skeleton: str,
    formatting_metadata: Optional[str] = None,
    highlight_ai: bool = False
) -> BytesIO:
    """Generate a Word document from a report"""
    generator = DocumentGenerator()
    return generator.generate_word_document(
        report_text, template_skeleton, formatting_metadata, highlight_ai
    )


def generate_report_pdf(
    report_text: str,
    template_skeleton: str,
    formatting_metadata: Optional[str] = None
) -> BytesIO:
    """Generate a PDF document from a report"""
    generator = DocumentGenerator()
    docx_stream = generator.generate_word_document(
        report_text, template_skeleton, formatting_metadata, highlight_ai_content=False
    )

    converter = PDFConverter()
    return converter.convert_docx_to_pdf(docx_stream)
